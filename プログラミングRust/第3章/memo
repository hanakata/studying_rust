3章 基本的な型

Rustの型にはいくつかの目的がある
・安全性
・効率性
・簡潔性
Rustは事前コンパイラ＝プログラム全体を機械語に翻訳する
→Rustは静的型付け
Rustは明示的に書いた型を用いて残りの型を推論してくれる
例えば
fn build_vector() -> Vec<i16>{
    let mut v: Vec<i16> = Vec::<i16>::new();
    v.push(10i16);
    v.push(20i16);
    v
}
これを
fn build_vector() -> Vec<i16>{
    let mut v: Vec = Vec::new();
    v.push(10);
    v.push(20);
    v
}
このように書くことができるのは推論してくれるから。

関数をジェネリックすることができる。
関数の目的と実装が十分一般的なものであれば
条件を満たすすべての関数が自然に動作する。

・機械語型
基盤は固定長の数値型と真偽型と文字型

デバッグビルドでは数値演算の際に整数のオーバーフローをチェックする。
例えば
let big_val = std::i32::MAX;//パニック。数値演算がオーバーフロー
let x = big_val + 1;
となっている場合、パニックが発生する。このような挙動をwrap（ラップ）と呼ぶ。
これを前提に書くべきではない。常にラップするように書くのであれば
let x = big_val.wrapping_add(1);
と書くようにすればよい。