3章 基本的な型

Rustの型にはいくつかの目的がある
・安全性
・効率性
・簡潔性
Rustは事前コンパイラ＝プログラム全体を機械語に翻訳する
→Rustは静的型付け
Rustは明示的に書いた型を用いて残りの型を推論してくれる
例えば
fn build_vector() -> Vec<i16>{
    let mut v: Vec<i16> = Vec::<i16>::new();
    v.push(10i16);
    v.push(20i16);
    v
}
これを
fn build_vector() -> Vec<i16>{
    let mut v: Vec = Vec::new();
    v.push(10);
    v.push(20);
    v
}
このように書くことができるのは推論してくれるから。

関数をジェネリックすることができる。
関数の目的と実装が十分一般的なものであれば
条件を満たすすべての関数が自然に動作する。

・機械語型
基盤は固定長の数値型と真偽型と文字型

デバッグビルドでは数値演算の際に整数のオーバーフローをチェックする。
例えば
let big_val = std::i32::MAX;//パニック。数値演算がオーバーフロー
let x = big_val + 1;
となっている場合、パニックが発生する。このような挙動をwrap（ラップ）と呼ぶ。
これを前提に書くべきではない。常にラップするように書くのであれば
let x = big_val.wrapping_add(1);
と書くようにすればよい。

整数型の型は大体推論してくれる。デフォルトはi32。

浮動小数点は正と負の無限大、正の0と負の0、数でない値(NAN)を含む。
デフォルトはf64

真偽値はtrueとfalse

文字は32ビットのchar型を用いる。

タプルは様々な型の組み合わせを保持することができる。
配列とはだいぶ違う。

ポインタ
・参照
・BOX・・・ヒープ上に値を確保する最も簡単な方法。
・rawポインタ・・・Rustが全く管理しないので安全ではない。

配列はコンパイル時にサイズが確定する。
ベクタは伸長可能
スライスは共有スライスと可変スライスがある。

文字列でダブルクォートで囲むとエスケープシーケンスが認識されない。
