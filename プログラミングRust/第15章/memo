15章 イテレータ

イテレータは値の列を生成する値で典型的には生成した値にループ処理を行うために用いる。
Rustのイテレータは柔軟で表現力が高く効率が良い。

例えば
fn triangle(n: i32) -> i32 {
    let mut sum = 0;
    for i in 1..n+1{
        sum += i;
    }
    sum
}
イテレータにはfoldメソッドがあるので同じ内容は以下のようにもかける
fn triangle(n: i32) -> i32 {
    (1..n+1)fold(0, |sum,item| sum + item)
}
foldは合計値の初期値を0として1..n+1の値を次々と受け取り、|sum,item|に合計値とそれぞれの値を与えて呼び出す。
この式が最後に返すのはfoldの値。
なれればfoldはコンパクトなループの代用品として使える。

IteratorとIntoIteratorのそれぞれのトレイトがイテレータの基盤

ある型に対して何か自然にスキャンする方法があるならその型はinteratorトレイトを実装することができる。

多くのコレクションはdrainメソッドを提供している。
これはコレクションへの可変参照を引数として取り、値の所有権を消費者に引き渡すイテレータを返す。

イテレータが手に入ればアダプタメソッドが利用できる。
mapアダプタは個々の要素に対してクロージャを適用するイテレータに変換する。
scanアダプタはmapににているが計算時に考慮すべき状態を表す可変値がクロージャに
渡される点と繰り返すを打ち切ることができる点が異なる。

一度Noneを返したIteratorに対して再度nextメソッドを呼び出した場合の動作をトレイトは既定していない。
fuseイテレータを利用することでそれを確実にすることができる。

chainアダプタで2つのイテレータをつなげることができる。

