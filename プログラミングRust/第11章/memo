11章 トレイトとジェネリクス

トレイトはRustにとってのインターフェイスもしくは抽象基底クラス。
例えば標準ライブラリのバイト列を書き出すトレイトstd::io::Writeの場合
trait Write{
    fn write(&mut self,buf: &[u8]) -> Result<usize>;
    fn flush(&mut self) -> Result<()>;
    fn write_all(&mut self, buf: &[u8]) -> Result<()>...
}
このトレイトを使うコードの場合、もともとの型を気にしない。

Rustはwrite型の変数を持つことができない。
→変数のサイズはコンパイル時に決まっている必要があるがwrite型はサイズが決まらないため。
write型を利用したければ参照を利用すること。
こういったトレイト型への参照をトレイトオブジェクトと呼ぶ。
トレイトオブジェクトは何らかの値を指し、生存期間を持ち、mutか共有可能かを選択する。
トレイトオブジェクトはコンパイル時に参照先の実際の型が分からないのが特徴。
トレイトオブジェクトで書くと以下のようになる
use std::io::Write;

fn say_hello(out: &mut Write) -> std::io::Result<()>{
    out.write_all(b"Hello world\n")?;
    out.flush()
}

これをジェネリック関数で書くとこうなる
use std::io::Write;

fn say_hello<W: Write>(out: &mut W) -> std::io::Result<()>{
    out.write_all(b"Hello world\n")?;
    out.flush()
}
<W: Write>で関数がジェネリックになる。
型パラメータは大文字1字で書くのが慣習。

トレイトオブジェクトとジェネリック関数で書くのとを選ぶのは微妙な問題。
複数の型が入り混じっているコレクションを使う場合にはトレイトオブジェクトを利用するのが正しい。
またコンパイルされた出力コードの総量も減る。

ジェネリック関数はスピードが速い。
またトレイトがトレイトオブジェクトを必ずサポートするわけではない。
なのでジェネリック関数を選ぶことが多い。

トレイトを実装する際にはトレイトか型のどちらかがクレートで新たに定義されたものでなければならない。
→一貫性ルール
トレイトではキーワードSelfを型として使うことができる。

メソッドはちょっと変わった関数だと思えばよい。
例えば
"hello".to_string()

str::to_string("hello")
は等価。